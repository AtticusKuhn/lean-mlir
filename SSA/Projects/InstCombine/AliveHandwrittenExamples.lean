
import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import SSA.Projects.InstCombine.Refinement
import SSA.Projects.InstCombine.Tactic
import SSA.Projects.InstCombine.LLVM.Signature
import SSA.Projects.InstCombine.LLVM.CLITests

open MLIR AST
open Std (BitVec)
open Ctxt (Var)

namespace AliveAutoGenerated
set_option pp.proofs false
set_option pp.proofs.withType false
open Qq Lean


/-
Name: SimplifyDivRemOfSelect

%sel = select %c, %Y, 0
%r = udiv %X, %sel
  =>
%r = udiv %X, %Y

-/

deftest alive_simplifyDivRemOfSelect_lhs :=
fun w : Nat =>
[mlir_icom_test ( w )| {
^bb0(%c : i1, %X : _, %Y : _):
  %v0  = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %sel = "llvm.select" (%c,%Y,%v0) : (i1, _, _) -> (_)
  %r   = "llvm.udiv" (%X,%sel) : (_, _) -> (_)
  "llvm.return" (%r) : (_) -> ()
}]

deftest alive_simplifyDivRemOfSelect_rhs  :=
fun (w : Nat) =>
[mlir_icom_test ( w )| {
^bb0(%c : i1, %X : _, %Y : _):
  %r = "llvm.udiv" (%X,%Y) : (_, _) -> (_)
  "llvm.return" (%r) : (_) -> ()
}]

#reduce alive_simplifyDivRemOfSelect_rhs 0

/-
deftest alive_simplifyDivRemOfSelect_rhs_constbw :=
[mlir_icom_test ( )| {
^bb0(%c : i1, %X : i8, %Y : i8):
  %r = "llvm.udiv" (%X,%Y) : (i8, i8) -> (i8)
  "llvm.return" (%r) : (i8) -> ()
}]

def alive_simplifyDivRemOfSelect  :=
fun (w : Nat) =>
  alive_simplifyDivRemOfSelect_lhs w ⊑  alive_simplifyDivRemOfSelect_rhs w := by
  unfold alive_simplifyDivRemOfSelect_lhs alive_simplifyDivRemOfSelect_rhs
  simp_alive_peephole
  -- goal: ⊢ BitVec.udiv? x1✝ (BitVec.select x2✝ x0✝ (BitVec.ofInt w 0)) ⊑ BitVec.udiv? x1✝ x0✝
  <;> sorry

def alive_unsound :
[mlir_icom ( )| {
^bb0():
  %v0  = "llvm.mlir.constant" () { value = 9 : i8 } :() -> (i8)
  %v1  = "llvm.mlir.constant" () { value = 1 : i8 } :() -> (i8)
  %undef  = "llvm.shl" (%v1,%v0) : (i8, i8) -> (i8)
  %r = "llvm.or" (%v1,%undef) : (i8, i8) -> (i8)
  "llvm.return" (%r) : (i8) -> ()
}] ⊑ [mlir_icom ( )| {
^bb0():
  %v0  = "llvm.mlir.constant" () { value = 2 : i8 } :() -> (i8)
  "llvm.return" (%v0) : (i8) -> ()
}] := by
  simp_alive_peephole
  simp [BitVec.toNat, BitVec.ofInt, BitVec.toFin, Fin.val]
-/

def allTests := llvmTests!
